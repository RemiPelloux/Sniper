"""
Docker integration utilities for Sniper.

This module provides functionality for managing Docker containers for various security tools,
allowing Sniper to fallback to containerized tools when native installations are not available.
"""

import logging
import os
import shutil
import subprocess
from typing import Dict, List, Optional, Tuple

log = logging.getLogger(__name__)

# Map of tool names to their Docker images
DOCKER_IMAGES = {
    "zap": "ghcr.io/zaproxy/zaproxy:stable",
    "nmap": "instrumentisto/nmap:latest",
    "dirsearch": "elsicarius/dirsearch:latest",
    "wappalyzer": "blacktop/wappalyzer:latest",
    "amass": "caffix/amass:latest",
    "subfinder": "projectdiscovery/subfinder:latest",
}

# Directory to store Docker wrapper scripts
DOCKER_WRAPPER_DIR = os.path.expanduser("~/.sniper/docker_wrappers")


def is_docker_available() -> bool:
    """
    Check if Docker is installed and available.

    Returns:
        bool: True if Docker is available, False otherwise
    """
    try:
        result = subprocess.run(
            ["docker", "--version"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=False,
        )
        return result.returncode == 0
    except (OSError, subprocess.SubprocessError):
        return False


def is_docker_compose_available() -> bool:
    """
    Check if Docker Compose is installed and available.

    Returns:
        bool: True if Docker Compose is available, False otherwise
    """
    try:
        # Try docker compose (new) or docker-compose (old)
        for cmd in [
            ["docker", "compose", "--version"],
            ["docker-compose", "--version"],
        ]:
            result = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=False,
            )
            if result.returncode == 0:
                return True
        return False
    except (OSError, subprocess.SubprocessError):
        return False


def pull_docker_image(image_name: str) -> bool:
    """
    Pull a Docker image.

    Args:
        image_name: The Docker image name to pull

    Returns:
        bool: True if the image was pulled successfully, False otherwise
    """
    try:
        log.info(f"Pulling Docker image: {image_name}")
        result = subprocess.run(
            ["docker", "pull", image_name],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=False,
        )
        return result.returncode == 0
    except (OSError, subprocess.SubprocessError) as e:
        log.error(f"Error pulling Docker image {image_name}: {e}")
        return False


def check_docker_image_exists(image_name: str) -> bool:
    """
    Check if a Docker image exists locally.

    Args:
        image_name: The Docker image name to check

    Returns:
        bool: True if the image exists locally, False otherwise
    """
    try:
        result = subprocess.run(
            ["docker", "image", "inspect", image_name],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=False,
        )
        return result.returncode == 0
    except (OSError, subprocess.SubprocessError):
        return False


def create_docker_wrapper(tool_name: str, docker_image: str) -> Optional[str]:
    """
    Create a wrapper script to run a tool via Docker.

    Args:
        tool_name: Name of the tool
        docker_image: Docker image to use

    Returns:
        str: Path to the wrapper script, or None if creation failed
    """
    if not os.path.exists(DOCKER_WRAPPER_DIR):
        try:
            os.makedirs(DOCKER_WRAPPER_DIR, exist_ok=True)
        except OSError as e:
            log.error(f"Failed to create directory {DOCKER_WRAPPER_DIR}: {e}")
            return None

    wrapper_path = os.path.join(DOCKER_WRAPPER_DIR, tool_name)

    try:
        with open(wrapper_path, "w") as f:
            f.write(
                f"""#!/bin/bash
# Docker wrapper for {tool_name}
# Generated by Sniper

# Run {tool_name} in Docker
docker run --rm -i {docker_image} "$@"
"""
            )

        # Make the wrapper executable
        os.chmod(wrapper_path, 0o755)

        log.info(f"Created Docker wrapper for {tool_name} at {wrapper_path}")
        return wrapper_path

    except (OSError, IOError) as e:
        log.error(f"Failed to create wrapper script for {tool_name}: {e}")
        return None


def setup_tool_docker_fallback(tool_name: str) -> Optional[str]:
    """
    Setup a Docker fallback for a tool if it's not available natively.

    Args:
        tool_name: Name of the tool

    Returns:
        str: Path to the wrapper script, or None if setup failed
    """
    if not is_docker_available():
        log.error("Docker is not available. Cannot setup Docker fallback.")
        return None

    # Check if the tool has a Docker image defined
    if tool_name not in DOCKER_IMAGES:
        log.error(f"No Docker image defined for tool: {tool_name}")
        return None

    docker_image = DOCKER_IMAGES[tool_name]

    # Check if the Docker image exists locally, pull if not
    if not check_docker_image_exists(docker_image):
        log.info(f"Docker image for {tool_name} not found locally. Pulling...")
        if not pull_docker_image(docker_image):
            log.error(f"Failed to pull Docker image for {tool_name}.")
            return None

    # Create wrapper script
    wrapper_path = create_docker_wrapper(tool_name, docker_image)
    if not wrapper_path:
        return None

    # Symlink to a location in PATH if possible
    symlink_dir = "/usr/local/bin"
    if os.path.exists(symlink_dir) and os.access(symlink_dir, os.W_OK):
        symlink_path = os.path.join(symlink_dir, tool_name)
        try:
            if os.path.exists(symlink_path):
                os.remove(symlink_path)
            os.symlink(wrapper_path, symlink_path)
            log.info(f"Created symlink to {tool_name} wrapper at {symlink_path}")
            return symlink_path
        except OSError as e:
            log.warning(
                f"Failed to create symlink for {tool_name}: {e}. Using wrapper directly."
            )
    else:
        log.info(f"No write permission to {symlink_dir}. Using wrapper directly.")

    return wrapper_path


def ensure_tool_available(tool_name: str) -> Tuple[bool, str]:
    """
    Ensure a tool is available, either natively or via Docker.

    Args:
        tool_name: Name of the tool

    Returns:
        Tuple[bool, str]: (is_available, path_or_error_message)
    """
    # First check if the tool is natively available
    native_path = shutil.which(tool_name)
    if native_path:
        return True, native_path

    log.info(f"Tool {tool_name} not found natively. Checking Docker fallback...")

    # Try to setup Docker fallback
    docker_path = setup_tool_docker_fallback(tool_name)
    if docker_path:
        return True, docker_path

    return (
        False,
        f"Tool {tool_name} is not available natively and Docker fallback failed.",
    )


def check_and_ensure_tools(required_tools: List[str]) -> Dict[str, Tuple[bool, str]]:
    """
    Check and ensure availability of multiple tools.

    Args:
        required_tools: List of tool names to check

    Returns:
        Dict[str, Tuple[bool, str]]: Dictionary of {tool_name: (is_available, path_or_error_message)}
    """
    results = {}
    for tool in required_tools:
        is_available, path_or_error = ensure_tool_available(tool)
        results[tool] = (is_available, path_or_error)

    return results
